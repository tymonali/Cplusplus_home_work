#include <iostream>

using namespace std;

struct Node                         //Звено дерева
{
	int x;                           //То, что записываем в дерево
	Node* l, * r;                      //Это указатели на новые звенья
};

void show(Node*& Tree)              //Функция обхода
{
	if (Tree != NULL)               //Пока не встретится пустое звено
	{
		show(Tree->l);               //Рекурсивная функция для вывода левого поддерева
		cout << Tree->x << " ";               //Отображаем корень дерева
		show(Tree->r);               //Рекурсивная функции для вывода правого поддерева
	}
}

/*Добавили очистку памяти*/
void del(Node*& Tree) 
{
	if (Tree != NULL)                //Пока не встретится пустое звено
	{
		del(Tree->l);                //Рекурсивная функция прохода по левому поддереву
		del(Tree->r);                //Рекурсивная функци для прохода по правому поддереву
		delete Tree;                 //Убиваем конечный элемент дерева
		Tree = NULL;                 //Может и не обязательно, но плохого не будет
	}
}

void add_node(int x, Node*& MyTree) //Функция добавления звена в дерево
{
	if (NULL == MyTree)             //То, о чем я в самом начале писал. Если дерева нет, то сеем семечко
	{
		MyTree = new Node;          //Выделяем память под звено дерева
		MyTree->x = x;              //Записываем данные в звено
		MyTree->l = MyTree->r = NULL; //Подзвенья инициализируем пустотой во избежание ошибок
	}
	if (x < MyTree->x)                   //Если нововведенный элемент x меньше чем элемент x из семечка дерева, уходим влево
	{
		if (MyTree->l != NULL) add_node(x, MyTree->l); //При помощи рекурсии заталкиваем элемент на свободный участок
		else                                          //Если элемент получил свой участок, то
		{
			MyTree->l = new Node;                      //Выделяем память левому подзвену. Именно подзвену, а не просто звену
			MyTree->l->l = MyTree->l->r = NULL;        //У левого подзвена будут свои левое и правое подзвенья, инициализируем их пустотой
			MyTree->l->x = x;                          //Записываем в левое подзвено записываемый элемент
		}
	}
	if (x > MyTree->x)              //Если нововведенный элемент x больше чем элемент x из семечка дерева, уходим вправо
	{
		if (MyTree->r != NULL) add_node(x, MyTree->r); //При помощи рекурсии заталкиваем элемент на свободный участок
		else              //Если элемент получил свой участок, то
		{
			MyTree->r = new Node;                 //Выделяем память правому подзвену. Именно подзвену, а не просто звену
			MyTree->r->l = MyTree->r->r = NULL;   //У правого подзвена будут свои левое и правое подзвенья, инициализируем их пустотой
			MyTree->r->x = x;                     //Записываем в правое подзвено записываемый элемент
		}
	}
}

int main()
{
	Node* Tree = NULL;               //Создаю указатель, тип которого = звено дерева и инициализирую его пустотой


	for (int i = 5; i > 0; i--) add_node(i, Tree);         //Я решил так заполнять
	show(Tree);                    //Вывод на экран дерева. или просто обход дерева
	cout << "\n";
	del(Tree);						//Чистка памяти! Распилили дерево

	for (int i = 20; i > 5; i--) add_node(i, Tree);        //На месте спиленного дерева можно растить новое
	show(Tree);                       //Смотрим, что выросло
	del(Tree);                        //Когда дерево уже не нужно, зачищаем память

	cin.get();	// Ожидание ввода с клавиатуры

	return 0;
}